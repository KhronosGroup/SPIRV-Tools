// Copyright (c) 2018 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef LIBSPIRV_OPT_SSA_REWRITE_PASS_H_
#define LIBSPIRV_OPT_SSA_REWRITE_PASS_H_

#include "basic_block.h"
#include "ir_context.h"
#include "mem_pass.h"

#include <unordered_map>

namespace spvtools {
namespace opt {

// Utility class for passes that need to rewrite a function into SSA.  This
// converts load/store operations on function-local variables into SSA IDs,
// which allows them to be the target of optimizing transformations.
//
// Store and load operations to these variables are converted into
// operations on SSA IDs.  Phi instructions are added when needed.  See the
// SSA construction paper for algorithmic details
// (https://link.springer.com/chapter/10.1007/978-3-642-37051-9_6)
class SSARewriter {
 public:
  SSARewriter(MemPass* pass) : pass_(pass) {}

  // Rewrites SSA-target variables in function |fp| into SSA.  This is the
  // entry point for the SSA rewrite algorithm.  SSA-target variables are
  // locally defined variables that meet the criteria set by IsSSATargetVar.
  //
  // It returns true if function |fp| was modified.  Otherwise, it returns
  // false.
  bool RewriteFunctionIntoSSA(ir::Function* fp);

 private:
  struct PhiCandidate {
    PhiCandidate(uint32_t var, uint32_t result, ir::BasicBlock* block)
        : var_id(var),
          result_id(result),
          bb(block),
          phi_args(),
          is_trivial(false) {}

    // Variable ID that this Phi is merging.
    uint32_t var_id;

    // SSA ID generated by this Phi (i.e., this is the result ID of the eventual
    // Phi instruction).
    uint32_t result_id;

    // Basic block to hold this Phi.
    ir::BasicBlock* bb;

    // Vector of operands for every predecessor block of |bb|.  This vector is
    // organized so that the Ith slot contains the argument coming from the Ith
    // predecessor of |bb|.
    std::vector<uint32_t> phi_args;

    // True, if this Phi candidate has been found to be trivial.
    bool is_trivial;

    // Pretty prints this Phi candidate into a string and returns it. |cfg| is
    // needed to lookup basic block predecessors.
    std::string PrettyPrint(const ir::CFG* cfg) const;

    // Returns true if this Phi candidate is incomplete.  Incomplete Phi
    // candidates are those that lack arguments or those that have at least one
    // nil argument.
    bool IsIncomplete() const {
      if (phi_args.size() == 0) {
        return true;
      } else {
        for (auto arg : phi_args) {
          if (arg == 0) return true;
        }
        return false;
      }
    }
  };

  // Type used to keep track of store operations in each basic block.
  typedef std::unordered_map<ir::BasicBlock*,
                             std::unordered_map<uint32_t, uint32_t>>
      BlockDefsMap;

  // Type used to keep track of potential Phi instructions in each basic block.
  typedef std::unordered_map<ir::BasicBlock*,
                             std::unordered_map<uint32_t, PhiCandidate>>
      BlockPhisMap;

  // Generates all the SSA rewriting decisions for basic block |bb|.  This
  // populates the Phi candidate table (|phi_candidate_|) and the load
  // replacement table (|load_replacement_).
  void GenerateSSAReplacements(ir::BasicBlock* bb);

  // Seals block |bb|.  Sealing a basic block means |bb| and all its
  // predecessors of |bb| have been scanned for loads/stores.
  void SealBlock(ir::BasicBlock* bb);

  // Returns true if |bb| has been sealed.
  bool IsBlockSealed(ir::BasicBlock* bb) {
    return sealed_blocks_.find(bb) != sealed_blocks_.end();
  }

  // Applies all the SSA replacement decisions.  This replaces loads/stores to
  // SSA target variables with their corresponding SSA IDs, and inserts Phi
  // instructions for them.
  bool ApplyReplacements();

  // Registers a definition for variable |var_id| in basic block |bb| with
  // value |val_id|.
  void WriteVariable(uint32_t var_id, ir::BasicBlock* bb, uint32_t val_id) {
    defs_at_block_[bb][var_id] = val_id;
  }

  // Populates the map of stores to SSA-target variables in basic block |bb|.
  // Returns an iterator pointing to the location of this map in
  // |defs_at_block_|.
  void ScanBlockForDefs(ir::BasicBlock* bb);

  // Processes the store operation |inst| in basic block |bb|. This extracts the
  // variable ID being stored into, determines whether the variable is an
  // SSA-target variable, and, if it is, it stores its value in the
  // |defs_at_block_| map.
  void ProcessStore(ir::Instruction* inst, ir::BasicBlock* bb);

  // Processes the load operation |inst| in basic block |bb|. This extracts the
  // variable ID being stored into, determines whether the variable is an
  // SSA-target variable, and, if it is, it reads its reaching definition by
  // calling |ReadVariable|.
  void ProcessLoad(ir::Instruction* inst, ir::BasicBlock* bb);

  // Reads the current definition for variable |var_id| in basic block |bb|.
  // If |var_id| is not defined in block |bb| it walks up the predecessors of
  // |bb|, creating new Phi instructions along the way, if needed.
  //
  // It returns the value for |var_id| from the RHS of the current reaching
  // definition for |var_id|.
  uint32_t ReadVariable(uint32_t var_id, ir::BasicBlock* bb);

  // Reads the current definition for variable |var_id| in predecessors of basic
  // block |bb|.  This continues looking up the CFG predecessors until it
  // eventually needs to insert a Phi instruction.
  //
  // It returns the value for |var_id| from the RHS of the current reaching
  // definition for |var_id|.
  uint32_t ReadVariableRecursive(uint32_t var_id, ir::BasicBlock* bb);

  // Creates a Phi candidate instruction for variable |var_id| in basic block
  // |bb|.  Phi candidates are potential Phi instructions that will be created
  // at the end of the SSA rewrite pass.
  //
  // Since the rewriting algorithm may remove Phi candidates when it finds them
  // to be trivial, we avoid the expense of creating actual Phi instructions by
  // keeping a pool of Phi candidates (|phi_candidates_|) during rewriting.
  //
  // Once the candidate Phi is created, it returns its ID.
  PhiCandidate& CreatePhiCandidate(uint32_t var_id, ir::BasicBlock* bb);

  // Adds operands to the Phi candidate |phi_cand|.  This may result in
  // |phi_cand| becoming a trivial Phi instruction.  When that happens,
  // |phi_cand| will get replaced by one of its operands.  This function will
  // return either the ID for |phi_cand| or the ID of the operand that replaced
  // it.
  uint32_t AddPhiOperands(PhiCandidate* phi_cand);

  // Attempts to remove a trivial Phi candidate |phi_cand|. Trivial Phis are
  // those that only reference themselves and one other value |val| any number
  // of times. This will try to remove any other Phis that become trivial after
  // |phi_cand| is removed.
  //
  // If |phi_cand| is trivial, it returns the SSA ID for the value that should
  // replace it.  Otherwise, it returns the SSA ID for |phi_cand|.
  uint32_t TryRemoveTrivialPhi(PhiCandidate* phi_cand);

  // Completes |phi_cand| by adding missing arguments or replacing unknown
  // arguments with their correct reaching definition.
  void CompletePhiCandidate(PhiCandidate* phi_cand);

  // Finalizes processing of Phi candidates.  Once the whole function has been
  // scanned for loads and stores, the CFG will still have some incomplete and
  // trivial Phis.  This will add missing arguments and remove trivial Phi
  // candidates.
  void FinalizePhiCandidates();

  // Map holding the value of every SSA-target variable at every basic block
  // where the variable is stored. defs_at_block_[block][var_id] = val_id
  // means that there is a store instruction for variable |var_id| at basic
  // block |block| with value |val_id|.
  BlockDefsMap defs_at_block_;

  // Map, indexed by basic block, holding all the Phi candidates created at that
  // basic block during SSA rewriting.  phi_candidates_[block] returns a map,
  // indexed by variable ID, for the Phi candidate created for that variable at
  // |block|.
  BlockPhisMap phi_candidates_;

  // SSA replacement table.  This maps variable IDs, resulting from a load
  // operation, to the value IDs that will replace them after SSA rewriting.
  // After all the rewriting decisions are made, a final scan through the IR is
  // done to replace all uses of the original load ID with the value ID.
  std::unordered_map<uint32_t, uint32_t> load_replacement_;

  // Set of blocks that have been sealed already.
  std::unordered_set<ir::BasicBlock*> sealed_blocks_;

  // Memory pass requesting the SSA rewriter.
  MemPass* pass_;
};

class SSARewritePass : public MemPass {
 public:
  SSARewritePass() = default;
  const char* name() const override { return "ssa-rewrite"; }
  Status Process(ir::IRContext* c) override;

 private:
  // Initializes the pass.
  void Initialize(ir::IRContext* c);
};

}  // namespace opt
}  // namespace spvtools

#endif  // LIBSPIRV_OPT_SSA_REWRITE_PASS_H_
