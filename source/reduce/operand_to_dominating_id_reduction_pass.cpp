// Copyright (c) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "operand_to_dominating_id_reduction_pass.h"
#include "change_operand_reduction_opportunity.h"
#include "source/opt/instruction.h"

namespace spvtools {
namespace reduce {

using namespace opt;

std::vector<std::unique_ptr<ReductionOpportunity>>
OperandToDominatingIdReductionPass::GetAvailableOpportunities(
    opt::IRContext* context) const {
  std::vector<std::unique_ptr<ReductionOpportunity>> result;

  // Go through every instruction in every block, considering it as a potential
  // dominator of other instructions.  We choose this order for two reasons:
  //
  // (1) it is profitable for multiple opportunities to replace the same id x by
  // different dominating ids y and z to be discontiguous, as they are
  // incompatible.
  //
  // (2) We want to prioritise opportunities to replace an id with a more
  // distant dominator.  Intuitively, in a human-readable programming language
  // if we have a complex expression e with many sub-expressions, we would like
  // to prioritise replacing e with its smallest sub-expressions; generalising
  // this idea to dominating ids this roughly corresponds to more distant
  // dominators.
  for (auto& function : *context->module()) {
    for (auto& block : function) {
      for (auto& dominating_inst : block) {
        if (dominating_inst.HasResultId() && dominating_inst.type_id()) {
          // Consider replacing any operand with matching type in a dominated
          // instruction with the id generated by this instruction.
          GetOpportunitiesForDominatingInst(&result, &dominating_inst,
                                            &function, context);
        }
      }
    }
  }
  return result;
}

void OperandToDominatingIdReductionPass::GetOpportunitiesForDominatingInst(
    std::vector<std::unique_ptr<ReductionOpportunity>>* opportunities,
    opt::Instruction* dominating_instruction, opt::Function* function,
    opt::IRContext* context) const {
  assert(dominating_instruction->HasResultId());
  assert(dominating_instruction->type_id());
  auto dominator_analysis = context->GetDominatorAnalysis(function);
  for (auto& block : *function) {
    for (auto& inst : block) {
      for (uint32_t i = 0; i < inst.NumOperands(); i++) {
        const auto& operand = inst.GetOperand(i);
        if (operand.type != SPV_OPERAND_TYPE_ID) {
          continue;
        }
        const auto id = operand.words[0];
        auto def = context->get_def_use_mgr()->GetDef(id);
        assert(def);
        if (!context->get_instr_block(def)) {
          // The definition does not come from a block; e.g. it might be a
          // constant.  It is thus not relevant to this pass.
          continue;
        }
        // Sanity check that we don't get here if the argument is a constant.
        assert(!context->get_constant_mgr()->GetConstantFromInst(def));
        if (dominating_instruction == def ||
            !dominator_analysis->Dominates(dominating_instruction, def)) {
          continue;
        }
        auto type_id = def->type_id();
        if (type_id != dominating_instruction->type_id()) {
          // The types need to match.
          continue;
        }
        opportunities->push_back(MakeUnique<ChangeOperandReductionOpportunity>(
            &inst, i, dominating_instruction->result_id()));
      }
    }
  }
}

std::string OperandToDominatingIdReductionPass::GetName() const {
  return "OperandToDominatingIdReductionPass";
}

}  // namespace reduce
}  // namespace spvtools
