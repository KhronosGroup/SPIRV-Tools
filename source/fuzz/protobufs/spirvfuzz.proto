syntax = "proto3";

package spvtools.fuzz.protobufs;

message IdUseDescriptor {

  // Describes a use of an id as an input operand to an instruction in some block
  // of a function.

  // An id that we would like to be able to find a use of.
  uint32 id_of_interest = 1;

  // The opcode for the instruction that uses the id.
  uint32 target_instruction_opcode = 2;

  // The input operand index at which the use is expected.
  uint32 in_operand_index = 3;

  // The id of an instruction after which the instruction that contains the use
  // is believed to occur; it might be the using instruction itself.
  uint32 base_instruction_result_id = 4;

  // The number of matching opcodes to skip over when searching for the using
  // instruction from the base instruction.
  uint32 num_opcodes_to_ignore = 5;

}

message UniformBufferElementDescriptor {

  // Represents a data element inside a uniform buffer via the result id
  // of a uniform variable instruction, and a series of indices to follow,
  // in order to drill through composite structures in the uniform buffer
  // to get to an element.

  // The result id of a uniform variable.
  uint32 uniform_variable_id = 1;

  // An ordered sequence of indices through composite structures in the
  // uniform buffer.
  repeated uint32 indices = 2;

}

message TransformationSequence {
  repeated Transformation transformations = 1;
}

message Transformation {
  oneof transformation {
    TransformationAddBooleanConstant add_boolean_constant = 1;
    TransformationAddDeadBreak add_dead_break = 2;
    TransformationMoveBlockDown move_block_down = 3;
    TransformationReplaceConstantWithUniform replace_constant_with_uniform = 4;
    TransformationSplitBlock split_block = 5;
  }
}

message TransformationAddBooleanConstant {

  // Supports adding the constants true and false to a module, which may be
  // necessary in order to enable other transformations if they are not present.

  uint32 fresh_id = 1;
  bool is_true = 2;

}

message TransformationAddDeadBreak {

  // A transformation that turns a basic block that unconditionally branches to
  // its successor into a block that potentially breaks out of a structured
  // control flow construct, but in such a manner that the break cannot actually
  // be taken.

  // The block to break from
  uint32 from_block = 1;

  // The merge block to break to
  uint32 to_block = 2;

  // Determines whether the break condition is true or false
  bool break_condition_value = 3;

  // A sequence of ids suitable for extending OpPhi instructions as a result of
  // the new break edge
  repeated uint32 phi_ids = 4;

}

message TransformationMoveBlockDown {
  // A transformation that moves a basic block to be one position lower in program
  // order.

  // The id of the block to move down.
  uint32 block_id = 1;
}

message TransformationReplaceConstantWithUniform {

  // A descriptor for the id we would like to replace
  IdUseDescriptor id_use_descriptor = 1;

  // Uniform descriptor to identify which uniform value to choose
  UniformBufferElementDescriptor uniform_descriptor = 2;

  // Id that will store the result of an access chain
  uint32 fresh_id_for_access_chain = 3;

  // Id that will store the result of a load
  uint32 fresh_id_for_load = 4;

}

message TransformationSplitBlock {

  // A transformation that splits a basic block into two basic blocks.

  // The result id of an instruction.
  uint32 result_id = 1;

  // An offset, such that the block containing |result_id_| should be split
  // right before the instruction |offset_| instructions after |result_id_|.
  uint32 offset = 2;

  // An id that must not yet be used by the module to which this transformation
  // is applied.  Rather than having the transformation choose a suitable id on
  // application, we require the id to be given upfront in order to facilitate
  // reducing fuzzed shaders by removing transformations.  The reason is that
  // future transformations may refer to the fresh id introduced by this
  // transformation, and if we end up changing what that id is, due to removing
  // earlier transformations, it may inhibit later transformations from
  // applying.
  uint32 fresh_id = 3;

}
