// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spirvfuzz.proto

#ifndef PROTOBUF_INCLUDED_spirvfuzz_2eproto
#define PROTOBUF_INCLUDED_spirvfuzz_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spirvfuzz_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_spirvfuzz_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_spirvfuzz_2eproto();
namespace spvtools {
namespace fuzz {
namespace protobufs {
class Transformation;
class TransformationDefaultTypeInternal;
extern TransformationDefaultTypeInternal _Transformation_default_instance_;
class TransformationAddBooleanConstant;
class TransformationAddBooleanConstantDefaultTypeInternal;
extern TransformationAddBooleanConstantDefaultTypeInternal _TransformationAddBooleanConstant_default_instance_;
class TransformationAddDeadBreak;
class TransformationAddDeadBreakDefaultTypeInternal;
extern TransformationAddDeadBreakDefaultTypeInternal _TransformationAddDeadBreak_default_instance_;
class TransformationMoveBlockDown;
class TransformationMoveBlockDownDefaultTypeInternal;
extern TransformationMoveBlockDownDefaultTypeInternal _TransformationMoveBlockDown_default_instance_;
class TransformationSequence;
class TransformationSequenceDefaultTypeInternal;
extern TransformationSequenceDefaultTypeInternal _TransformationSequence_default_instance_;
class TransformationSplitBlock;
class TransformationSplitBlockDefaultTypeInternal;
extern TransformationSplitBlockDefaultTypeInternal _TransformationSplitBlock_default_instance_;
}  // namespace protobufs
}  // namespace fuzz
}  // namespace spvtools
namespace google {
namespace protobuf {
template<> ::spvtools::fuzz::protobufs::Transformation* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::Transformation>(Arena*);
template<> ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::TransformationAddBooleanConstant>(Arena*);
template<> ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::TransformationAddDeadBreak>(Arena*);
template<> ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::TransformationMoveBlockDown>(Arena*);
template<> ::spvtools::fuzz::protobufs::TransformationSequence* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::TransformationSequence>(Arena*);
template<> ::spvtools::fuzz::protobufs::TransformationSplitBlock* Arena::CreateMaybeMessage<::spvtools::fuzz::protobufs::TransformationSplitBlock>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace spvtools {
namespace fuzz {
namespace protobufs {

// ===================================================================

class TransformationSequence :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.TransformationSequence) */ {
 public:
  TransformationSequence();
  virtual ~TransformationSequence();

  TransformationSequence(const TransformationSequence& from);

  inline TransformationSequence& operator=(const TransformationSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationSequence(TransformationSequence&& from) noexcept
    : TransformationSequence() {
    *this = ::std::move(from);
  }

  inline TransformationSequence& operator=(TransformationSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransformationSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationSequence* internal_default_instance() {
    return reinterpret_cast<const TransformationSequence*>(
               &_TransformationSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TransformationSequence* other);
  friend void swap(TransformationSequence& a, TransformationSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationSequence* New() const final {
    return CreateMaybeMessage<TransformationSequence>(nullptr);
  }

  TransformationSequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationSequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationSequence& from);
  void MergeFrom(const TransformationSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spvtools.fuzz.protobufs.Transformation transformations = 1;
  int transformations_size() const;
  void clear_transformations();
  static const int kTransformationsFieldNumber = 1;
  ::spvtools::fuzz::protobufs::Transformation* mutable_transformations(int index);
  ::google::protobuf::RepeatedPtrField< ::spvtools::fuzz::protobufs::Transformation >*
      mutable_transformations();
  const ::spvtools::fuzz::protobufs::Transformation& transformations(int index) const;
  ::spvtools::fuzz::protobufs::Transformation* add_transformations();
  const ::google::protobuf::RepeatedPtrField< ::spvtools::fuzz::protobufs::Transformation >&
      transformations() const;

  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.TransformationSequence)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::spvtools::fuzz::protobufs::Transformation > transformations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// -------------------------------------------------------------------

class Transformation :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.Transformation) */ {
 public:
  Transformation();
  virtual ~Transformation();

  Transformation(const Transformation& from);

  inline Transformation& operator=(const Transformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transformation(Transformation&& from) noexcept
    : Transformation() {
    *this = ::std::move(from);
  }

  inline Transformation& operator=(Transformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transformation& default_instance();

  enum TransformationCase {
    kAddBooleanConstant = 1,
    kAddDeadBreak = 2,
    kMoveBlockDown = 3,
    kSplitBlock = 4,
    TRANSFORMATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transformation* internal_default_instance() {
    return reinterpret_cast<const Transformation*>(
               &_Transformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Transformation* other);
  friend void swap(Transformation& a, Transformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transformation* New() const final {
    return CreateMaybeMessage<Transformation>(nullptr);
  }

  Transformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transformation& from);
  void MergeFrom(const Transformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .spvtools.fuzz.protobufs.TransformationAddBooleanConstant add_boolean_constant = 1;
  bool has_add_boolean_constant() const;
  void clear_add_boolean_constant();
  static const int kAddBooleanConstantFieldNumber = 1;
  const ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant& add_boolean_constant() const;
  ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* release_add_boolean_constant();
  ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* mutable_add_boolean_constant();
  void set_allocated_add_boolean_constant(::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* add_boolean_constant);

  // .spvtools.fuzz.protobufs.TransformationAddDeadBreak add_dead_break = 2;
  bool has_add_dead_break() const;
  void clear_add_dead_break();
  static const int kAddDeadBreakFieldNumber = 2;
  const ::spvtools::fuzz::protobufs::TransformationAddDeadBreak& add_dead_break() const;
  ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* release_add_dead_break();
  ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* mutable_add_dead_break();
  void set_allocated_add_dead_break(::spvtools::fuzz::protobufs::TransformationAddDeadBreak* add_dead_break);

  // .spvtools.fuzz.protobufs.TransformationMoveBlockDown move_block_down = 3;
  bool has_move_block_down() const;
  void clear_move_block_down();
  static const int kMoveBlockDownFieldNumber = 3;
  const ::spvtools::fuzz::protobufs::TransformationMoveBlockDown& move_block_down() const;
  ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* release_move_block_down();
  ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* mutable_move_block_down();
  void set_allocated_move_block_down(::spvtools::fuzz::protobufs::TransformationMoveBlockDown* move_block_down);

  // .spvtools.fuzz.protobufs.TransformationSplitBlock split_block = 4;
  bool has_split_block() const;
  void clear_split_block();
  static const int kSplitBlockFieldNumber = 4;
  const ::spvtools::fuzz::protobufs::TransformationSplitBlock& split_block() const;
  ::spvtools::fuzz::protobufs::TransformationSplitBlock* release_split_block();
  ::spvtools::fuzz::protobufs::TransformationSplitBlock* mutable_split_block();
  void set_allocated_split_block(::spvtools::fuzz::protobufs::TransformationSplitBlock* split_block);

  void clear_transformation();
  TransformationCase transformation_case() const;
  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.Transformation)
 private:
  class HasBitSetters;
  void set_has_add_boolean_constant();
  void set_has_add_dead_break();
  void set_has_move_block_down();
  void set_has_split_block();

  inline bool has_transformation() const;
  inline void clear_has_transformation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TransformationUnion {
    TransformationUnion() {}
    ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* add_boolean_constant_;
    ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* add_dead_break_;
    ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* move_block_down_;
    ::spvtools::fuzz::protobufs::TransformationSplitBlock* split_block_;
  } transformation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// -------------------------------------------------------------------

class TransformationAddBooleanConstant :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.TransformationAddBooleanConstant) */ {
 public:
  TransformationAddBooleanConstant();
  virtual ~TransformationAddBooleanConstant();

  TransformationAddBooleanConstant(const TransformationAddBooleanConstant& from);

  inline TransformationAddBooleanConstant& operator=(const TransformationAddBooleanConstant& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationAddBooleanConstant(TransformationAddBooleanConstant&& from) noexcept
    : TransformationAddBooleanConstant() {
    *this = ::std::move(from);
  }

  inline TransformationAddBooleanConstant& operator=(TransformationAddBooleanConstant&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransformationAddBooleanConstant& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationAddBooleanConstant* internal_default_instance() {
    return reinterpret_cast<const TransformationAddBooleanConstant*>(
               &_TransformationAddBooleanConstant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TransformationAddBooleanConstant* other);
  friend void swap(TransformationAddBooleanConstant& a, TransformationAddBooleanConstant& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationAddBooleanConstant* New() const final {
    return CreateMaybeMessage<TransformationAddBooleanConstant>(nullptr);
  }

  TransformationAddBooleanConstant* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationAddBooleanConstant>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationAddBooleanConstant& from);
  void MergeFrom(const TransformationAddBooleanConstant& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationAddBooleanConstant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 fresh_id = 1;
  void clear_fresh_id();
  static const int kFreshIdFieldNumber = 1;
  ::google::protobuf::uint32 fresh_id() const;
  void set_fresh_id(::google::protobuf::uint32 value);

  // bool is_true = 2;
  void clear_is_true();
  static const int kIsTrueFieldNumber = 2;
  bool is_true() const;
  void set_is_true(bool value);

  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.TransformationAddBooleanConstant)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 fresh_id_;
  bool is_true_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// -------------------------------------------------------------------

class TransformationAddDeadBreak :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.TransformationAddDeadBreak) */ {
 public:
  TransformationAddDeadBreak();
  virtual ~TransformationAddDeadBreak();

  TransformationAddDeadBreak(const TransformationAddDeadBreak& from);

  inline TransformationAddDeadBreak& operator=(const TransformationAddDeadBreak& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationAddDeadBreak(TransformationAddDeadBreak&& from) noexcept
    : TransformationAddDeadBreak() {
    *this = ::std::move(from);
  }

  inline TransformationAddDeadBreak& operator=(TransformationAddDeadBreak&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransformationAddDeadBreak& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationAddDeadBreak* internal_default_instance() {
    return reinterpret_cast<const TransformationAddDeadBreak*>(
               &_TransformationAddDeadBreak_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TransformationAddDeadBreak* other);
  friend void swap(TransformationAddDeadBreak& a, TransformationAddDeadBreak& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationAddDeadBreak* New() const final {
    return CreateMaybeMessage<TransformationAddDeadBreak>(nullptr);
  }

  TransformationAddDeadBreak* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationAddDeadBreak>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationAddDeadBreak& from);
  void MergeFrom(const TransformationAddDeadBreak& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationAddDeadBreak* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 phi_ids = 4;
  int phi_ids_size() const;
  void clear_phi_ids();
  static const int kPhiIdsFieldNumber = 4;
  ::google::protobuf::uint32 phi_ids(int index) const;
  void set_phi_ids(int index, ::google::protobuf::uint32 value);
  void add_phi_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      phi_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_phi_ids();

  // uint32 from_block = 1;
  void clear_from_block();
  static const int kFromBlockFieldNumber = 1;
  ::google::protobuf::uint32 from_block() const;
  void set_from_block(::google::protobuf::uint32 value);

  // uint32 to_block = 2;
  void clear_to_block();
  static const int kToBlockFieldNumber = 2;
  ::google::protobuf::uint32 to_block() const;
  void set_to_block(::google::protobuf::uint32 value);

  // bool break_condition_value = 3;
  void clear_break_condition_value();
  static const int kBreakConditionValueFieldNumber = 3;
  bool break_condition_value() const;
  void set_break_condition_value(bool value);

  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.TransformationAddDeadBreak)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > phi_ids_;
  mutable std::atomic<int> _phi_ids_cached_byte_size_;
  ::google::protobuf::uint32 from_block_;
  ::google::protobuf::uint32 to_block_;
  bool break_condition_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// -------------------------------------------------------------------

class TransformationMoveBlockDown :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.TransformationMoveBlockDown) */ {
 public:
  TransformationMoveBlockDown();
  virtual ~TransformationMoveBlockDown();

  TransformationMoveBlockDown(const TransformationMoveBlockDown& from);

  inline TransformationMoveBlockDown& operator=(const TransformationMoveBlockDown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationMoveBlockDown(TransformationMoveBlockDown&& from) noexcept
    : TransformationMoveBlockDown() {
    *this = ::std::move(from);
  }

  inline TransformationMoveBlockDown& operator=(TransformationMoveBlockDown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransformationMoveBlockDown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationMoveBlockDown* internal_default_instance() {
    return reinterpret_cast<const TransformationMoveBlockDown*>(
               &_TransformationMoveBlockDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TransformationMoveBlockDown* other);
  friend void swap(TransformationMoveBlockDown& a, TransformationMoveBlockDown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationMoveBlockDown* New() const final {
    return CreateMaybeMessage<TransformationMoveBlockDown>(nullptr);
  }

  TransformationMoveBlockDown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationMoveBlockDown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationMoveBlockDown& from);
  void MergeFrom(const TransformationMoveBlockDown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationMoveBlockDown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 block_id = 1;
  void clear_block_id();
  static const int kBlockIdFieldNumber = 1;
  ::google::protobuf::uint32 block_id() const;
  void set_block_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.TransformationMoveBlockDown)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 block_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// -------------------------------------------------------------------

class TransformationSplitBlock :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:spvtools.fuzz.protobufs.TransformationSplitBlock) */ {
 public:
  TransformationSplitBlock();
  virtual ~TransformationSplitBlock();

  TransformationSplitBlock(const TransformationSplitBlock& from);

  inline TransformationSplitBlock& operator=(const TransformationSplitBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationSplitBlock(TransformationSplitBlock&& from) noexcept
    : TransformationSplitBlock() {
    *this = ::std::move(from);
  }

  inline TransformationSplitBlock& operator=(TransformationSplitBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransformationSplitBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationSplitBlock* internal_default_instance() {
    return reinterpret_cast<const TransformationSplitBlock*>(
               &_TransformationSplitBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TransformationSplitBlock* other);
  friend void swap(TransformationSplitBlock& a, TransformationSplitBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationSplitBlock* New() const final {
    return CreateMaybeMessage<TransformationSplitBlock>(nullptr);
  }

  TransformationSplitBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationSplitBlock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationSplitBlock& from);
  void MergeFrom(const TransformationSplitBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationSplitBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 result_id = 1;
  void clear_result_id();
  static const int kResultIdFieldNumber = 1;
  ::google::protobuf::uint32 result_id() const;
  void set_result_id(::google::protobuf::uint32 value);

  // uint32 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // uint32 fresh_id = 3;
  void clear_fresh_id();
  static const int kFreshIdFieldNumber = 3;
  ::google::protobuf::uint32 fresh_id() const;
  void set_fresh_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:spvtools.fuzz.protobufs.TransformationSplitBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 result_id_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 fresh_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_spirvfuzz_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransformationSequence

// repeated .spvtools.fuzz.protobufs.Transformation transformations = 1;
inline int TransformationSequence::transformations_size() const {
  return transformations_.size();
}
inline void TransformationSequence::clear_transformations() {
  transformations_.Clear();
}
inline ::spvtools::fuzz::protobufs::Transformation* TransformationSequence::mutable_transformations(int index) {
  // @@protoc_insertion_point(field_mutable:spvtools.fuzz.protobufs.TransformationSequence.transformations)
  return transformations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::spvtools::fuzz::protobufs::Transformation >*
TransformationSequence::mutable_transformations() {
  // @@protoc_insertion_point(field_mutable_list:spvtools.fuzz.protobufs.TransformationSequence.transformations)
  return &transformations_;
}
inline const ::spvtools::fuzz::protobufs::Transformation& TransformationSequence::transformations(int index) const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationSequence.transformations)
  return transformations_.Get(index);
}
inline ::spvtools::fuzz::protobufs::Transformation* TransformationSequence::add_transformations() {
  // @@protoc_insertion_point(field_add:spvtools.fuzz.protobufs.TransformationSequence.transformations)
  return transformations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spvtools::fuzz::protobufs::Transformation >&
TransformationSequence::transformations() const {
  // @@protoc_insertion_point(field_list:spvtools.fuzz.protobufs.TransformationSequence.transformations)
  return transformations_;
}

// -------------------------------------------------------------------

// Transformation

// .spvtools.fuzz.protobufs.TransformationAddBooleanConstant add_boolean_constant = 1;
inline bool Transformation::has_add_boolean_constant() const {
  return transformation_case() == kAddBooleanConstant;
}
inline void Transformation::set_has_add_boolean_constant() {
  _oneof_case_[0] = kAddBooleanConstant;
}
inline void Transformation::clear_add_boolean_constant() {
  if (has_add_boolean_constant()) {
    delete transformation_.add_boolean_constant_;
    clear_has_transformation();
  }
}
inline ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* Transformation::release_add_boolean_constant() {
  // @@protoc_insertion_point(field_release:spvtools.fuzz.protobufs.Transformation.add_boolean_constant)
  if (has_add_boolean_constant()) {
    clear_has_transformation();
      ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* temp = transformation_.add_boolean_constant_;
    transformation_.add_boolean_constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant& Transformation::add_boolean_constant() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.Transformation.add_boolean_constant)
  return has_add_boolean_constant()
      ? *transformation_.add_boolean_constant_
      : *reinterpret_cast< ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant*>(&::spvtools::fuzz::protobufs::_TransformationAddBooleanConstant_default_instance_);
}
inline ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant* Transformation::mutable_add_boolean_constant() {
  if (!has_add_boolean_constant()) {
    clear_transformation();
    set_has_add_boolean_constant();
    transformation_.add_boolean_constant_ = CreateMaybeMessage< ::spvtools::fuzz::protobufs::TransformationAddBooleanConstant >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:spvtools.fuzz.protobufs.Transformation.add_boolean_constant)
  return transformation_.add_boolean_constant_;
}

// .spvtools.fuzz.protobufs.TransformationAddDeadBreak add_dead_break = 2;
inline bool Transformation::has_add_dead_break() const {
  return transformation_case() == kAddDeadBreak;
}
inline void Transformation::set_has_add_dead_break() {
  _oneof_case_[0] = kAddDeadBreak;
}
inline void Transformation::clear_add_dead_break() {
  if (has_add_dead_break()) {
    delete transformation_.add_dead_break_;
    clear_has_transformation();
  }
}
inline ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* Transformation::release_add_dead_break() {
  // @@protoc_insertion_point(field_release:spvtools.fuzz.protobufs.Transformation.add_dead_break)
  if (has_add_dead_break()) {
    clear_has_transformation();
      ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* temp = transformation_.add_dead_break_;
    transformation_.add_dead_break_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::spvtools::fuzz::protobufs::TransformationAddDeadBreak& Transformation::add_dead_break() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.Transformation.add_dead_break)
  return has_add_dead_break()
      ? *transformation_.add_dead_break_
      : *reinterpret_cast< ::spvtools::fuzz::protobufs::TransformationAddDeadBreak*>(&::spvtools::fuzz::protobufs::_TransformationAddDeadBreak_default_instance_);
}
inline ::spvtools::fuzz::protobufs::TransformationAddDeadBreak* Transformation::mutable_add_dead_break() {
  if (!has_add_dead_break()) {
    clear_transformation();
    set_has_add_dead_break();
    transformation_.add_dead_break_ = CreateMaybeMessage< ::spvtools::fuzz::protobufs::TransformationAddDeadBreak >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:spvtools.fuzz.protobufs.Transformation.add_dead_break)
  return transformation_.add_dead_break_;
}

// .spvtools.fuzz.protobufs.TransformationMoveBlockDown move_block_down = 3;
inline bool Transformation::has_move_block_down() const {
  return transformation_case() == kMoveBlockDown;
}
inline void Transformation::set_has_move_block_down() {
  _oneof_case_[0] = kMoveBlockDown;
}
inline void Transformation::clear_move_block_down() {
  if (has_move_block_down()) {
    delete transformation_.move_block_down_;
    clear_has_transformation();
  }
}
inline ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* Transformation::release_move_block_down() {
  // @@protoc_insertion_point(field_release:spvtools.fuzz.protobufs.Transformation.move_block_down)
  if (has_move_block_down()) {
    clear_has_transformation();
      ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* temp = transformation_.move_block_down_;
    transformation_.move_block_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::spvtools::fuzz::protobufs::TransformationMoveBlockDown& Transformation::move_block_down() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.Transformation.move_block_down)
  return has_move_block_down()
      ? *transformation_.move_block_down_
      : *reinterpret_cast< ::spvtools::fuzz::protobufs::TransformationMoveBlockDown*>(&::spvtools::fuzz::protobufs::_TransformationMoveBlockDown_default_instance_);
}
inline ::spvtools::fuzz::protobufs::TransformationMoveBlockDown* Transformation::mutable_move_block_down() {
  if (!has_move_block_down()) {
    clear_transformation();
    set_has_move_block_down();
    transformation_.move_block_down_ = CreateMaybeMessage< ::spvtools::fuzz::protobufs::TransformationMoveBlockDown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:spvtools.fuzz.protobufs.Transformation.move_block_down)
  return transformation_.move_block_down_;
}

// .spvtools.fuzz.protobufs.TransformationSplitBlock split_block = 4;
inline bool Transformation::has_split_block() const {
  return transformation_case() == kSplitBlock;
}
inline void Transformation::set_has_split_block() {
  _oneof_case_[0] = kSplitBlock;
}
inline void Transformation::clear_split_block() {
  if (has_split_block()) {
    delete transformation_.split_block_;
    clear_has_transformation();
  }
}
inline ::spvtools::fuzz::protobufs::TransformationSplitBlock* Transformation::release_split_block() {
  // @@protoc_insertion_point(field_release:spvtools.fuzz.protobufs.Transformation.split_block)
  if (has_split_block()) {
    clear_has_transformation();
      ::spvtools::fuzz::protobufs::TransformationSplitBlock* temp = transformation_.split_block_;
    transformation_.split_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::spvtools::fuzz::protobufs::TransformationSplitBlock& Transformation::split_block() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.Transformation.split_block)
  return has_split_block()
      ? *transformation_.split_block_
      : *reinterpret_cast< ::spvtools::fuzz::protobufs::TransformationSplitBlock*>(&::spvtools::fuzz::protobufs::_TransformationSplitBlock_default_instance_);
}
inline ::spvtools::fuzz::protobufs::TransformationSplitBlock* Transformation::mutable_split_block() {
  if (!has_split_block()) {
    clear_transformation();
    set_has_split_block();
    transformation_.split_block_ = CreateMaybeMessage< ::spvtools::fuzz::protobufs::TransformationSplitBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:spvtools.fuzz.protobufs.Transformation.split_block)
  return transformation_.split_block_;
}

inline bool Transformation::has_transformation() const {
  return transformation_case() != TRANSFORMATION_NOT_SET;
}
inline void Transformation::clear_has_transformation() {
  _oneof_case_[0] = TRANSFORMATION_NOT_SET;
}
inline Transformation::TransformationCase Transformation::transformation_case() const {
  return Transformation::TransformationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransformationAddBooleanConstant

// uint32 fresh_id = 1;
inline void TransformationAddBooleanConstant::clear_fresh_id() {
  fresh_id_ = 0u;
}
inline ::google::protobuf::uint32 TransformationAddBooleanConstant::fresh_id() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddBooleanConstant.fresh_id)
  return fresh_id_;
}
inline void TransformationAddBooleanConstant::set_fresh_id(::google::protobuf::uint32 value) {
  
  fresh_id_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddBooleanConstant.fresh_id)
}

// bool is_true = 2;
inline void TransformationAddBooleanConstant::clear_is_true() {
  is_true_ = false;
}
inline bool TransformationAddBooleanConstant::is_true() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddBooleanConstant.is_true)
  return is_true_;
}
inline void TransformationAddBooleanConstant::set_is_true(bool value) {
  
  is_true_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddBooleanConstant.is_true)
}

// -------------------------------------------------------------------

// TransformationAddDeadBreak

// uint32 from_block = 1;
inline void TransformationAddDeadBreak::clear_from_block() {
  from_block_ = 0u;
}
inline ::google::protobuf::uint32 TransformationAddDeadBreak::from_block() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddDeadBreak.from_block)
  return from_block_;
}
inline void TransformationAddDeadBreak::set_from_block(::google::protobuf::uint32 value) {
  
  from_block_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddDeadBreak.from_block)
}

// uint32 to_block = 2;
inline void TransformationAddDeadBreak::clear_to_block() {
  to_block_ = 0u;
}
inline ::google::protobuf::uint32 TransformationAddDeadBreak::to_block() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddDeadBreak.to_block)
  return to_block_;
}
inline void TransformationAddDeadBreak::set_to_block(::google::protobuf::uint32 value) {
  
  to_block_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddDeadBreak.to_block)
}

// bool break_condition_value = 3;
inline void TransformationAddDeadBreak::clear_break_condition_value() {
  break_condition_value_ = false;
}
inline bool TransformationAddDeadBreak::break_condition_value() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddDeadBreak.break_condition_value)
  return break_condition_value_;
}
inline void TransformationAddDeadBreak::set_break_condition_value(bool value) {
  
  break_condition_value_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddDeadBreak.break_condition_value)
}

// repeated uint32 phi_ids = 4;
inline int TransformationAddDeadBreak::phi_ids_size() const {
  return phi_ids_.size();
}
inline void TransformationAddDeadBreak::clear_phi_ids() {
  phi_ids_.Clear();
}
inline ::google::protobuf::uint32 TransformationAddDeadBreak::phi_ids(int index) const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationAddDeadBreak.phi_ids)
  return phi_ids_.Get(index);
}
inline void TransformationAddDeadBreak::set_phi_ids(int index, ::google::protobuf::uint32 value) {
  phi_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationAddDeadBreak.phi_ids)
}
inline void TransformationAddDeadBreak::add_phi_ids(::google::protobuf::uint32 value) {
  phi_ids_.Add(value);
  // @@protoc_insertion_point(field_add:spvtools.fuzz.protobufs.TransformationAddDeadBreak.phi_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransformationAddDeadBreak::phi_ids() const {
  // @@protoc_insertion_point(field_list:spvtools.fuzz.protobufs.TransformationAddDeadBreak.phi_ids)
  return phi_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransformationAddDeadBreak::mutable_phi_ids() {
  // @@protoc_insertion_point(field_mutable_list:spvtools.fuzz.protobufs.TransformationAddDeadBreak.phi_ids)
  return &phi_ids_;
}

// -------------------------------------------------------------------

// TransformationMoveBlockDown

// uint32 block_id = 1;
inline void TransformationMoveBlockDown::clear_block_id() {
  block_id_ = 0u;
}
inline ::google::protobuf::uint32 TransformationMoveBlockDown::block_id() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationMoveBlockDown.block_id)
  return block_id_;
}
inline void TransformationMoveBlockDown::set_block_id(::google::protobuf::uint32 value) {
  
  block_id_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationMoveBlockDown.block_id)
}

// -------------------------------------------------------------------

// TransformationSplitBlock

// uint32 result_id = 1;
inline void TransformationSplitBlock::clear_result_id() {
  result_id_ = 0u;
}
inline ::google::protobuf::uint32 TransformationSplitBlock::result_id() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationSplitBlock.result_id)
  return result_id_;
}
inline void TransformationSplitBlock::set_result_id(::google::protobuf::uint32 value) {
  
  result_id_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationSplitBlock.result_id)
}

// uint32 offset = 2;
inline void TransformationSplitBlock::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 TransformationSplitBlock::offset() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationSplitBlock.offset)
  return offset_;
}
inline void TransformationSplitBlock::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationSplitBlock.offset)
}

// uint32 fresh_id = 3;
inline void TransformationSplitBlock::clear_fresh_id() {
  fresh_id_ = 0u;
}
inline ::google::protobuf::uint32 TransformationSplitBlock::fresh_id() const {
  // @@protoc_insertion_point(field_get:spvtools.fuzz.protobufs.TransformationSplitBlock.fresh_id)
  return fresh_id_;
}
inline void TransformationSplitBlock::set_fresh_id(::google::protobuf::uint32 value) {
  
  fresh_id_ = value;
  // @@protoc_insertion_point(field_set:spvtools.fuzz.protobufs.TransformationSplitBlock.fresh_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobufs
}  // namespace fuzz
}  // namespace spvtools

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_spirvfuzz_2eproto
